#include "RTIMULib.h"
#include "RTMath.h"
#include <iostream>
#include <vector>
using namespace std;

//void RTUMULibDrive()
extern "C"{
	int sampleCount = 0;
	int sampleRate = 0;
	uint64_t rateTimer;
	uint64_t displayTimer;
	uint64_t now;
	RTIMUSettings *settings;
	RTIMU *imu;
	
	float degree[3];
	vector<float> vecX;
	vector<float> vecY;
	vector<float> vecZ;

	void gyroInit();
	void getDegree(float degree[]);
	RTFLOAT gyroSensor();
	
	void showVector(){
		int i;
		for(i=0;i<vecX.size();i++){
			printf("%d => %f %f %f\n",i,vecX[i],vecY[i],vecZ[i]);
		}
	}

	void storeVector(){
		getDegree(degree);
		vecX.push_back(degree[0]);
		vecY.push_back(degree[1]);
		vecZ.push_back(degree[2]);
	}

	void gyroInit(){
		//  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
		//  Or, you can create the .ini in some other directory by using:
		//      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
		//  where <directory path> is the path to where the .ini file is to be loaded/saved
		settings = new RTIMUSettings("RTIMULib");
		imu = RTIMU::createIMU(settings);

		if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
			printf("No IMU found\n");
			exit(1);
		}
		//  This is an opportunity to manually override any settings before the call IMUInit
		//  set up IMU
		imu->IMUInit();
		//  this is a convenient place to change fusion parameters
		imu->setSlerpPower(0.02);
		imu->setGyroEnable(true);
		imu->setAccelEnable(true);
		imu->setCompassEnable(true);
		//  set up for rate timer
		rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();
		//  now just process data
	}

	void getDegree(float degree[]){
		//  now just process data
		while (1) {
			//  poll at the rate recommended by the IMU
			while (imu->IMURead()) {
				RTIMU_DATA imuData = imu->getIMUData();
				degree[0] = imuData.fusionPose.x() * RTMATH_RAD_TO_DEGREE;
				degree[1] = imuData.fusionPose.y() * RTMATH_RAD_TO_DEGREE;
				degree[2] = imuData.fusionPose.z() * RTMATH_RAD_TO_DEGREE;
				printf("\n");
				//printf("***degree test*** x = %f, y = %f, z = %f\n",degreeX,degreeY,degreeZ);
				return ;
			}
		}
	}
	RTFLOAT gyroSensor()
	{
		float degreeX, degreeY, degreeZ;
		while (1) {
			//  poll at the rate recommended by the IMU
			usleep(imu->IMUGetPollInterval() * 1000);

			while (imu->IMURead()) {
				RTIMU_DATA imuData = imu->getIMUData();
				sampleCount++;
				now = RTMath::currentUSecsSinceEpoch();

				//  display 10 times per second

				if ((now - displayTimer) > 100000) {
					degreeX = imuData.fusionPose.x() * RTMATH_RAD_TO_DEGREE;
					degreeY = imuData.fusionPose.y() * RTMATH_RAD_TO_DEGREE;
					degreeZ = imuData.fusionPose.z() * RTMATH_RAD_TO_DEGREE;
					printf("***degree test*** x = %f, y = %f, z = %f\n",degreeX,degreeY,degreeZ);
					displayTimer = now;
				}

				//  update rate every second
				if ((now - rateTimer) > 1000000) {
					sampleRate = sampleCount;
					sampleCount = 0;
					rateTimer = now;
				}
			}
		}
	}
}
